# -*- coding: utf-8 -*-
"""integral.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eBM6jzsdzXvXe9Ui6QOGLhyBk8iavEVy
"""

"""
Eros Moreira Ferreira
10/07/2024
Calcula uma intrgral pelo método do trapézio.
"""
import numpy as np

# Função que será integrada.
f = lambda x: 0.9*(np.exp(0.15*x)*np.cos(-0.4*x))

# limites de integração
a = float(input('Digite o limite inferior \n'))
b = float(input('Digite o limite superior \n'))


def trapezio(f, a, b, intmax = 100, precisao = 1e-6):
    """
    Calcula uma integral pelo método do trapézio.

    args:
       f(func): função que será integrada
       a (float): limite de integração inferior
       b (float): limite de integração superior
       intmax (int): default: 100. número máximo de iterações
       precisao (float): precisão relativa.

    return
      tuple: integral,número de interação, precisao relativa.
    """
    k = 0
    t_anterior = 10**16 # inicializando com valor alto assim como na apostila.
    t = 0.5 * (f(a) + f(b)) # valor da função nos extremos.
    while k < intmax:

        DELX_k = (b-a) / 2**k # delta x
        fj = 0

        for j in range(1,2**k):
            fj += f(a + j*DELX_k)

        tk  = (DELX_k) * (fj + t) # valor da integral.

        err_relativo = abs((tk-t_anterior)/tk)
        if err_relativo < precisao: # verifica se a precisao foi atingida.
            break
        else:
            t_anterior = tk
            k+=1
    return tk,k,err_relativo

integral, n, err= trapezio(f, a, b)
print(f'Precisão relativa: {err}\nNúmero de interações: {n}\
\nValor da integral: {integral: .6f}')

"""
O método de Newton-Raphson não funcionaria para achar a raiz
no dado o ponto 8.75 como valor inicial, por que a derivada
nesse ponto é zero. O método de NR depende da derivada ser difernte
de zero no chute incial.
"""